// Copyright 2020-2021 Kenneth Claassen. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "AnimNode_MotionRecorder.h"
#include "Animation/AnimNodeBase.h"
#include "Animation/AnimNode_AssetPlayerBase.h"
#include "CustomAssets/MotionCalibration.h"
#include "CustomAssets/MotionDataAsset.h"
#include "Data/AnimChannelState.h"
#include "Data/AnimMirroringData.h"
#include "Data/MotionTraitField.h"
#include "Data/PoseMotionData.h"
#include "Data/Trajectory.h"
#include "Enumerations/EMotionMatchingEnums.h"
#include "AnimNode_MSMotionMatching.generated.h"

struct FDistanceMatchPayload;
struct FMotionActionPayload;
struct FMotionTraitField;

/** An animation node which performs motion matching to synthesise animation. It is an asset player
which uses MotionAnimData asset as it's source data. The node can be used with inertialization and 
also the pose snapshot node which is also a part of Motion Symphony. */
USTRUCT(BlueprintInternalUseOnly) 
struct MOTIONSYMPHONY_API FAnimNode_MSMotionMatching : public FAnimNode_AssetPlayerBase
{
	GENERATED_BODY()

public:
	/** The desired trajectory of the character. This is the primary input and must be generated via a 'Trajectory Generator' 
	component on the character. Past trajectory is recorded from historical character positions and future trajectory is 
	predicted using a movement model over several iterations. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Trajectory", meta = (PinShownByDefault))
	FTrajectory DesiredTrajectory;

	/** The time interval between motion matching updates. This is not the frame rate or the rate at which the pose is 
	updated. Instead this is merely the rate at which pose searches are performed on the motion matching database. Keeping
	this value around 0.1 is good for performance as the search will only be done every few frames and higher update rates
	do not necessarily provide better quality. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "General", meta = (PinHiddenByDefault, ClampMin = 0.0f))
	float UpdateInterval;

	/** The playback speed of animations generated by this node.*/
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "General", meta = (PinHiddenByDefault, ClampMin = 0.0f))
	float PlaybackRate;

	/** The blend time between animation changes. This time should ideally be very small (0.2 - 0.3s) so as to avoid
	muddy animation. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "General", meta = (PinHiddenByDefault, ClampMin = 0.0f))
	float BlendTime;

	/** This ratio is used to alter calibration of pose vs. trajectory at runtime. The calibration has it's own pose-trajectory
	 * ratio which is fixed following pre-processing. However, this override multiplier will also be applied for runtime
	 * adjustments. Please note that this setting is very sensitive and should be used carefully. Normal setting of 0.5f will
	 * not affect the motion matching. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "General", meta = (PinHiddenByDefault, ClampMin = 0.0f, ClampMax = 1.0f))
	float OverrideQualityVsResponsivenessRatio;

#if WITH_EDITORONLY_DATA
	/** The source pose database for motion matching. This asset must be created and configured in your project and
	referenced here. */
	UPROPERTY(EditAnywhere, Category = "Animation Data", meta = (PinHiddenByDefault, FoldProperty))
	TObjectPtr<UMotionDataAsset> MotionData = nullptr;
	
	/** Reference to the calibration asset for motion matching. This is a modular asset which can be created and 
	configured in you project. It will use to control weightings for motion matching aspects that affect the 
	selection and synthesis of animation poses. */
	UPROPERTY(EditAnywhere, Category = "Animation Data", meta = (PinHiddenByDefault, FoldProperty))
	TObjectPtr<UMotionCalibration> UserCalibration = nullptr;
#endif
	
	/** The final calibrations used for the pose search. The UserCalibration is combined with the standard deviation
	calibration set to provide a normalized calibration to get the best motion matching results. There is a calibration
	set for each combination of motion traits*/
	UPROPERTY()
	TMap<FMotionTraitField, FCalibrationData> FinalCalibrationSets;
	
	/** If checked, animations will be blended out early before they reach their end to avoid 'stuck poses'. This is 
	a recommended setting for cut clips but may not be required for inertialization. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Options")
	bool bBlendOutEarly;

	/** The method of pose matching to use. I.e. whether to use the optimised module search or the built in linear search. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Options")
	EPoseMatchMethod PoseMatchMethod;

	/** The method of transitioning between animations. This could either be instant, blended or inertialized. Inertialization is
	the recommended method of blending with motion matching for both performance and quality. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Options")
	ETransitionMethod TransitionMethod;

	/** This is the method for handling the past trajectory. It can either be recorded (history) or it can be taken from the 
	current pose. The latter option is preferable if you are using procedural motion a lot but may cause other issues. Please try 
	both options and see what works best for you. (Note: Root motion users should use history) */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Options", meta = (PinHiddenByDefault))
	EPastTrajectoryMode PastTrajectoryMode;

	/** If true, the desired will be blended with the current trajectory with a time falloff. This provides a very realistic 
	trajectory but it can also reduce responsiveness. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Trajectory")
	bool bBlendTrajectory;

	/** The total amount of blending allowed by trajectory blending. This is a value between 0 and 1, where 1 is fully blended and
	0 is no blending. By using this value you can strike a balance in trajectory blending between quality and responsiveness. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Trajectory", meta = (ClampMin = 0.0f, ClampMax = 1.0f))
	float TrajectoryBlendMagnitude;

	/** If true, the current pose will be favoured by the 'CurrentPoseFavour' factor. This can help reduce the number of 'jumps' 
	in motion matching to allow for smooth consistent animation when it is appropriate. Note that excessive use of this feature
	can lead to un-responsive animation. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pose Favour")
	bool bFavourCurrentPose;

	/** The cost multiplier for favouring the current pose to be used in conjunction with 'FavourCurrentPose' option. 
	The value is a cost multiplier to the pose cost so a value of 1 is no change, lower values make the pose more favoured,
	while higher values make the pose less favourable. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pose Favour", meta = (PinHiddenByDefault, ClampMin = 0.0f))
	float CurrentPoseFavour;

	/** The next pose tolerance test is a performance check to see if the 'next pose' in the database is good enough. If
	so then the pose search will be cancelled and the current animation will keep playing. It is recommended to always use
	this as it will often trigger when the cahracter is moving straight and save a lot of performance. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pose Tolerance Test")
	bool bEnableToleranceTest;

	/** Position tolerance for the 'ToleranceTest'. When the pose tolerance test is performed it checks that the trajectory
	of th next pose does not differ from the desired trajectory more than this position threshold. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pose Tolerance Test", meta = (ClampMin = 0.0f))
	float PositionTolerance;

	/** Rotational (or facing) tolerance for the 'ToleranceTest'. When the pose tolerance test is performed it checks 
	that the trajectory	of th next pose does not differ from the desired trajectory more than this rotation threshold. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pose Tolerance Test", meta = (ClampMin = 0.0f))
	float RotationTolerance;

	/** The traits that are currently required. This is an important dynamic input into the node and can be used to 
	control which part of the animation database to search. Traits can be set for certain animation sections in the 
	MotionAnimData asset. Only poses with the RequiredTraits will be searched.*/
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Traits", meta = (PinHiddenByDefault))
	FMotionTraitField RequiredTraits;

	/** A payload of data used to control distance matching within motion matching. This is an experimental 
	feature and is not production ready. Use at your own risk.*/
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Distance Matching", meta = (PinHiddenByDefault))
	FDistanceMatchPayload DistanceMatchPayload;

	/** A payload of data used to explicitely play animation within motion matching. This is an experimental 
	feature and is not production ready. Use at your own risk. */
	//UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Motion Actions", meta = (PinHiddenByDefault))
	FMotionActionPayload MotionActionPayload;

	FDistanceMatchSection* ActiveDistanceMatchSection;
	float DistanceMatchTime;
	int32 LastDistanceMatchKeyChecked;

	int32 CurrentActionId;
	float CurrentActionTime;
	float CurrentActionEndTime;

private:
	float TimeSinceMotionUpdate;
	float TimeSinceMotionChosen;
	float PoseInterpolationValue;
	bool bForcePoseSearch;
	int32 CurrentChosenPoseId;
	int32 DominantBlendChannel;

	bool bValidToEvaluate;
	bool bInitialized;
	bool bTriggerTransition;

	FPoseMotionData CurrentInterpolatedPose;
	TArray<FAnimChannelState> BlendChannels;
	FTrajectory ActualTrajectory;

	EMotionMatchingMode MotionMatchingMode;

	//MotionSnapshot BoneRemapping
	//TArray<int32> PoseBoneRemap;
	TArray<FName> PoseBoneNames;

	//Debug
	TArray<int32> HistoricalPosesSearchCounts;
	FAnimInstanceProxy* AnimInstanceProxy; //For Debug drawingR

	FAnimMirroringData MirroringData;

public:
	FAnimNode_MSMotionMatching();
	virtual ~FAnimNode_MSMotionMatching() override;

	//FAnimNode_AssetPlayerBase interface
	virtual float GetCurrentAssetTime() const override;
	virtual float GetCurrentAssetTimePlayRateAdjusted() const override;
	virtual float GetCurrentAssetLength() const override;
	virtual UAnimationAsset* GetAnimAsset() const override;
	//End of FAnimNode_AssetPlayerBase interface
	

	// FAnimNode_Base interface
	virtual bool NeedsOnInitializeAnimInstance() const override;
	virtual void OnInitializeAnimInstance(const FAnimInstanceProxy* InAnimInstanceProxy, const UAnimInstance* InAnimInstance) override;
	virtual void Initialize_AnyThread(const FAnimationInitializeContext& Context) override;
	virtual void UpdateAssetPlayer(const FAnimationUpdateContext& Context) override;
	virtual void Evaluate_AnyThread(FPoseContext& Output) override;
	virtual void GatherDebugData(FNodeDebugData& DebugData) override;
	// End of FAnimNode_Base interface

private:
	void UpdateBlending(const float DeltaTime);
	void InitializeWithPoseRecorder(const FAnimationUpdateContext& Context);
	void InitializeMatchedTransition(const FAnimationUpdateContext& Context);
	void InitializeDistanceMatching(const FAnimationUpdateContext& Context);
	void InitializeMotionAction(const FAnimationUpdateContext& Context);
	void UpdateMotionMatchingState(const float DeltaTime, const FAnimationUpdateContext& Context);
	void UpdateDistanceMatchingState(const float DeltaTime, const FAnimationUpdateContext& Context);
	void UpdateMotionActionState(const float DeltaTime, const FAnimationUpdateContext& Context);
	void UpdateMotionMatching(const float DeltaTime, const FAnimationUpdateContext& Context);
	bool UpdateDistanceMatching(const float DeltaTime, const FAnimationUpdateContext& Context);
	void ComputeCurrentPose();
	void ComputeCurrentPose(const FCachedMotionPose& CachedMotionPose);
	void SchedulePoseSearch(const FAnimationUpdateContext& Context);
	void ScheduleTransitionPoseSearch(const FAnimationUpdateContext& Context);
	int32 GetLowestCostPoseId();
	int32 GetLowestCostPoseId(const FPoseMotionData& NextPose);
	int32 GetLowestCostPoseId_Linear(const FPoseMotionData& NextPose);
	bool NextPoseToleranceTest(FPoseMotionData& NextPose);
	void ApplyTrajectoryBlending();

	void TransitionToPose(const int32 PoseId, const FAnimationUpdateContext& Context, const float TimeOffset = 0.0f);
	void JumpToPose(const int32 PoseId, const float TimeOffset = 0.0f);
	void BlendToPose(const int32 PoseId, const float TimeOffset = 0.0f);

	UMotionDataAsset* GetMotionData() const;
	UMotionCalibration* GetUserCalibration() const;
	void CheckValidToEvaluate(const FAnimInstanceProxy* InAnimInstanceProxy);

	UAnimSequence* GetAnimAtIndex(const int32 AnimId);
	UAnimSequenceBase* GetPrimaryAnim();
	UAnimSequenceBase* GetPrimaryAnim() const;
	void EvaluateSinglePose(FPoseContext& Output);
	void EvaluateBlendPose(FPoseContext& Output);
	void CreateTickRecordForNode(const FAnimationUpdateContext& Context, float PlayRate);

	void PerformLinearSearchComparison(const FAnimationUpdateContext& Context, int32 ComparePoseId, FPoseMotionData& NextPose);

	void DrawTrajectoryDebug(FAnimInstanceProxy* InAnimInstanceProxy);
	void DrawChosenTrajectoryDebug(FAnimInstanceProxy* InAnimInstanceProxy);
	void DrawChosenPoseDebug(FAnimInstanceProxy* InAnimInstanceProxy, bool bDrawVelocity);
	void DrawCandidateTrajectories(TArray<FPoseMotionData>* Candidates);
	void DrawPoseTrajectory(FAnimInstanceProxy* InAnimInstanceProxy, FPoseMotionData& Pose, FTransform& CharTransform);
	void DrawSearchCounts(FAnimInstanceProxy* InAnimInstanceProxy);
	void DrawAnimDebug(FAnimInstanceProxy* InAnimInstanceProxy) const;
};